const path = require('path')
const fs = require('fs-extra')

//读取Swargger JSON 文件, 接受结果为对象
fs.readJson('./swagger.json', async (err, packageObj) => {
  if (err) console.error(err)
  const swarggerJSON = packageObj
  const clientMethods = generateClientAPIMethods(swarggerJSON)
  const apiClientPath = path.resolve(__dirname, path.join('api.js'))
  await fs.writeFile(apiClientPath, clientMethods)
})

//转换的js文件
function generateClientAPIMethods (methods) {
  const body = generateClientAPIMethodsBody(methods)
  return (
    '// This file is autogenerated by NuxtApi.js\n' +
    `export default client => ({\n${body}})`
  )
}

//对象解析操作
function generateClientAPIMethodsBody (methods, loadedMethods = '', path = null, level = 1) {
  //所属模块
  let tagsNameArray = []
  //遍历tags
  if (methods.tags.length) {
    methods.tags.forEach((item, index) => {
      loadedMethods += `  ${item.name}: {\n`
      for (const prop of Object.keys(methods.paths)) {
        let propArray = prop.split('/')
        let propLength = propArray.length
        if (propLength) {
          //方法名字（取最后一位）
          let funName = propArray[propLength - 1]
          //请求方式
          let methodName = Object.keys(methods.paths[prop])[0]
          //有相等的值并且方法名和请求方式都存在
          if (propArray.includes(methods.tags[index].name) && funName && methodName) {
            //添加动态对象键名下的属性
            loadedMethods += `    // ${eval('methods.paths[prop].' + methodName).summary}\n`
            loadedMethods += `    ${funName} (params) {\n`
            loadedMethods += `      return context.$axios.${methodName}('${prop}', {\n`
            loadedMethods += `        params\n`
            loadedMethods += `      })\n`
            loadedMethods += `    },\n`
          }
        }
      }
      loadedMethods += `  },\n`
      tagsNameArray.push(item.name)
    })
  }
  return loadedMethods
}